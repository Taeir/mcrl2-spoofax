module analysis2/mcrl2

signature

  sorts ID  = string
  sorts INT = int
  
  //---------------------------------------------------------------------------
  //Program and sections
  sorts Program constructors
    Program : list(Section) -> Program
  
  sorts Section constructors
//    ProcessSection     : list(ProcessDecl) -> Section
    ActionSection      : list(ActionDecl) -> Section
//    InitSection        : ProcExp -> Section
    SortSection        : list(SortDecl) -> Section
    ConstructorSection : list(IdsDecl) -> Section
    MapSection         : list(IdsDecl) -> Section
//    GlobalVarsSection  : list(VarsDeclList) -> Section
//    VarSection         : list(VarsDeclList) -> Section
    EquationsSection   : list(EqnDecl) -> Section
  
  sorts IdsDecl constructors
    TypedParams : list(ID) * SortExp -> IdsDecl
  
  //---------------------------------------------------------------------------
  //Actions
  sorts ActionDecl constructors
    ActionDecl    : list(ID) -> ActionDecl
    ActionDeclExt : list(ID) * list(SortExp) -> ActionDecl
  
  sorts ActionRef constructors
    ActionRef : ID -> ActionRef
  
  //---------------------------------------------------------------------------
  //Data
  sorts DataExp constructors
    DataRef        : ID -> DataExp
    Number         : INT -> DataExp
    True           : DataExp
    False          : DataExp
    EmptyList      : DataExp
    EmptySet       : DataExp
    EmptyBag       : DataExp
    List           : list(DataExp) -> DataExp
    Bag            : list(BagEnumElt) -> DataExp //TODO
//    SetBag         : VarDecl * DataExp -> DataExp //TODO
    Set            : list(DataExp) -> DataExp
    FunctionUpdate : DataExp * DataExp * DataExp -> DataExp
    FunctionApp    : DataExp * list(DataExp) -> DataExp
    DataBinExp     : DataBinOp * DataExp * DataExp -> DataExp
    DataUnExp      : DataUnOp * DataExp -> DataExp
    
    Existential    : list(VarsDecl) * DataExp -> DataExp
    Universal      : list(VarsDecl) * DataExp -> DataExp
    Lambda         : list(VarsDecl) * DataExp -> DataExp
    
  sorts DataBinOp constructors
    Implication   : DataBinOp
    Conjunction   : DataBinOp
    Disjunction   : DataBinOp
    
    Equality      : DataBinOp
    InEquality    : DataBinOp
    Smaller       : DataBinOp
    SmallerEqual  : DataBinOp
    Larger        : DataBinOp
    LargerEqual   : DataBinOp
    
    Membership    : DataBinOp
    ListCons      : DataBinOp
    ListSnoc      : DataBinOp
    ListConcat    : DataBinOp
    ListElementAt : DataBinOp
    
    Add      : DataBinOp
    Subtract : DataBinOp
    Divide   : DataBinOp
    IntDiv   : DataBinOp
    IntMod   : DataBinOp
    Mult     : DataBinOp
    
    Where : DataBinOp
    
  sorts DataUnOp constructors
    Negate : DataUnOp
    Minus  : DataUnOp
    Size   : DataUnOp
  
  sorts BagEnumElt constructors
    BagElement : DataExp * DataExp -> BagEnumElt
  
  sorts VarsDecl constructors
    VarsDecl : list(ID) * SortExp -> VarsDecl
  
  //---------------------------------------------------------------------------
  //Equations
  sorts EqnDecl constructors
    EqnDecl            : DataExp * DataExp -> EqnDecl
    EqnDeclConditioned : DataExp * DataExp * DataExp -> EqnDecl
  
  //---------------------------------------------------------------------------
  //Sorts
  sorts SortDecl constructors
    SortDecls : list(SortDeclID) -> SortDecl
    SortAlias : ID * SortExp     -> SortDecl
  
  sorts SortDeclID constructors
    SortDeclID   : ID       -> SortDeclID
  
  sorts SortExp constructors
    Boolean      : SortExp
    PositiveNr   : SortExp
    NaturalNr    : SortExp
    Integer      : SortExp
    Real         : SortExp
    SList        : SortExp -> SortExp
    SSet         : SortExp -> SortExp
    SBag         : SortExp -> SortExp
    SortRef      : ID -> SortExp
    FunctionSort : list(SortExp) * SortExp -> SortExp
    Struct       : list(ConstrDecl) -> SortExp
  
  sorts ConstrDecl constructors
    ConstrDecl : ID * ConstrArgs * ConstrFunction -> ConstrDecl
  
  sorts ConstrArgs constructors
    Args   : list(ProjDecl) -> ConstrArgs
    NoArgs : ConstrArgs
  
  sorts ConstrFunction constructors
    ConstrFunction   : ID -> ConstrFunction
    NoConstrFunction : ConstrFunction
  
  sorts ProjDecl constructors
    ProjDecl      : SortExp      -> ProjDecl
    ProjDeclNamed : ID * SortExp -> ProjDecl

  //---------------------------------------------------------------------------
  //Types
  sorts Type constructors
    BoolType   : Type
    
    PosType    : Type
    NatType    : Type
    IntType    : Type
    RealType   : Type
    
    ListType   : Type -> Type
    SetType    : Type -> Type
    BagType    : Type -> Type
    
    StructType : scope -> Type
    FunctionType : list(Type) * Type -> Type
    
    SortType   : string -> Type
    
    ActionType : Type
    
    AnyType    : Type
  
  //---------------------------------------------------------------------------
  relations
    typeOfDecl : occurrence -> Type
  
  namespaces
    Var    : string
    Action : string
    Sort   : string
    StructConstructor : string
    Function : string
    
  name-resolution
    labels P
    
    resolve Action   filter lexicalPathMatch min lexicalPathOrd
    resolve Sort     filter lexicalPathMatch min lexicalPathOrd
    resolve Var      filter lexicalPathMatch min lexicalPathOrd
    resolve Function filter lexicalPathMatch min lexicalPathOrd
    resolve StructConstructor filter lexicalPathMatch min lexicalPathOrd

rules
  lexicalPathMatch : list(label)
  lexicalPathOrd   : label * label

  lexicalPathMatch(p)    :- pathMatch[P*](p).
  lexicalPathOrd(p1, p2) :- pathLt[$ < P](p1, p2).

//-----------------------------------------------------------------------------
//Program
rules
  programOK : Program
  programOK(Program(sections)) :- {s}
    new s,
    sectionsOK(s, sections).

//Sections
rules
  sectionOK : scope * Section
  sectionsOK maps sectionOK(*, list(*))
  
  sectionOK(s, ActionSection(actionDecls)) :-
    actionDeclsOK(s, actionDecls).
  
  sectionOK(s, SortSection(sortDecls)) :-
    sortDeclsOK(s, sortDecls).
  
  sectionOK(s, EquationsSection(equationDecls)) :-
    equationDeclsOK(s, equationDecls).
  
  sectionOK(s, MapSection(mapDecls)) :-
    mapDeclsOK(s, mapDecls).

//-----------------------------------------------------------------------------
//Actions
rules
  actionOK     : scope * string * Type
  actionDeclOK : scope * ActionDecl
  actionDeclsOK     maps actionDeclOK(*, list(*))
  actionDeclNamesOK maps actionOK(*, list(*), *)
   
  actionDeclOK(s, ActionDecl(names)) :-
    actionDeclNamesOK(s, names, ActionType()).
  
  actionDeclOK(s, ActionDeclExt(names, args)) :- {argTypes}
    typeOfSortExps(s, args) == argTypes,
    actionDeclNamesOK(s, names, FunctionType(argTypes, ActionType())).

  //Action declaration
  actionOK(s, name, t) :-
    s -> Action{name@name} with typeOfDecl t.

//-----------------------------------------------------------------------------
//Map
rules
  mapDeclNameOK  : scope * string * Type
  mapDeclOK      : scope * IdsDecl
  mapDeclsOK maps mapDeclOK(*, list(*))
  mapDeclNamesOK maps mapDeclNameOK(*, list(*), *)
  
  
  mapDeclOK(s, TypedParams(names, sexp)) :- {t}
    typeOfSortExp(s, sexp) == t,
    mapDeclNamesOK(s, names, t).
    
  mapDeclNameOK(s, name, t) :-
    s -> Function{name@name} with typeOfDecl t.
  
  
  
  

//-----------------------------------------------------------------------------
//Sorts
rules
  sortOK     : scope * SortDeclID
  sortDeclOK : scope * SortDecl
  sortDeclsOK maps sortDeclOK(*, list(*))
  sortDeclNamesOK maps sortOK(*, list(*))
  
  sortDeclOK(s, SortDecls(names)) :-
    sortDeclNamesOK(s, names).
  
  sortDeclOK(s, SortAlias(name, sexp)) :- {T}
    typeOfSortExp(s, sexp) == T,
    s -> Sort{name@name} with typeOfDecl T.
  
  sortOK(s, SortDeclID(name)) :- 
    s -> Sort{name@name} with typeOfDecl SortType(name).

rules
  
  typeOfSortExp : scope * SortExp -> Type
  typeOfSortExps maps typeOfSortExp(*, list(*)) = list(*)
  
  //Simple types
  typeOfSortExp(s, Boolean())    = BoolType().
  
  //Numbers
  typeOfSortExp(s, PositiveNr()) = PosType().
  typeOfSortExp(s, NaturalNr())  = NatType().
  typeOfSortExp(s, Integer())    = IntType().
  typeOfSortExp(s, Real())       = RealType().
  
  //Collections
  typeOfSortExp(s, SList(sexp)) = L :- {T}
    typeOfSortExp(s, sexp) == T,
    ListType(T) == L.
  typeOfSortExp(s, SBag(sexp)) = L :- {T}
    typeOfSortExp(s, sexp) == T,
    BagType(T) == L.
  typeOfSortExp(s, SSet(sexp)) = L :- {T}
    typeOfSortExp(s, sexp) == T,
    SetType(T) == L.
  
  //References
  typeOfSortExp(s, SortRef(name)) = T :-
    query typeOfDecl filter lexicalPathMatch and { Sort{name'@_} :- name' == name }
          in s |-> [(_, (_, T))].
  
  //Functions
  typeOfSortExp(s, FunctionSort(args, sexp)) = T :- {argTypes retType}
    typeOfSortExps(s, args) == argTypes,
    typeOfSortExp(s, sexp) == retType,
    T == FunctionType(argTypes, retType).
  
  //Struct
  typeOfSortExp(s, Struct(constrs)) = T :- {struct_scope}
    new struct_scope,
    resolveConstructors(s, struct_scope, constrs).
  
  //Struct constructors
  resolveConstructor : scope * scope * ConstrDecl
  resolveConstructors maps resolveConstructor(*, *, list(*))
  
  resolveConstructor(s, struct_scope, ConstrDecl(name, NoArgs(), NoConstrFunction())) :- {d_constructor T}
    d_constructor == StructConstructor{name@name},
    T == StructType(struct_scope),
    struct_scope -> d_constructor with typeOfDecl T,
    s            -> d_constructor with typeOfDecl T.
  
  resolveConstructor(s, struct_scope, ConstrDecl(name, NoArgs(), ConstrFunction(funName))) :- {d_constructor T}
    d_constructor == StructConstructor{name@name},
    T == StructType(struct_scope),
    struct_scope -> d_constructor with typeOfDecl T,
    s            -> d_constructor with typeOfDecl T,
    s -> Function{funName@funName} with typeOfDecl FunctionType([T], BoolType()).
    
  resolveConstructor(s, struct_scope, ConstrDecl(name, Args(args), NoConstrFunction())) :- {d_constructor T argTypes}
    d_constructor == StructConstructor{name@name},
    typeOfProjDecls(s, args) == argTypes,
    T == StructType(struct_scope),
    struct_scope -> d_constructor with typeOfDecl T,
    s            -> d_constructor with typeOfDecl T.
  
  resolveConstructor(s, struct_scope, ConstrDecl(name, Args(args), ConstrFunction(funName))) :- {d_constructor T}
    d_constructor == StructConstructor{name@name},
    T == StructType(struct_scope),
    struct_scope -> d_constructor with typeOfDecl T,
    s            -> d_constructor with typeOfDecl T,
    s -> Function{funName@funName} with typeOfDecl FunctionType([T], BoolType()).
  
  typeOfProjDecl : scope * ProjDecl -> Type
  typeOfProjDecls maps typeOfProjDecl(*, list(*)) = list(*)
  
  typeOfProjDecl(s, ProjDecl(sexp)) = T :-
    typeOfSortExp(s, sexp) == T.
  typeOfProjDecl(s, ProjDeclNamed(_, sexp)) = T :-
    //TODO Use the name somewhere or at least store it (as a relation on the type?)
    typeOfSortExp(s, sexp) == T.

//-----------------------------------------------------------------------------
//Equations
rules
  equationOK : scope * EqnDecl
  equationDeclsOK maps equationOK(*, list(*))
  
  equationOK(s, EqnDecl(dexp1, dexp2)) :- {T F}
    typeOfDataExp(s, dexp1) == T,
    typeOfDataExp(s, dexp2) == F.
    //TODO F is subtype of T
  
  equationOK(s, EqnDeclConditioned(condition, dexp1, dexp2)) :- {T F}
    typeOfDataExp(s, condition) == BoolType(),
    typeOfDataExp(s, dexp1) == T,
    typeOfDataExp(s, dexp2) == F.
    //TODO F is subtype of T
  
//-----------------------------------------------------------------------------
//Data
rules
  typeOfDataExp : scope * DataExp -> Type
  typeOfDataExps maps typeOfDataExp(*, list(*)) = list(*)
  
  
  //References can occur to StructConstructor, Function and Var
  typeOfDataExp(s, DataRef(name)) = T :-
    query typeOfDecl filter lexicalPathMatch and { d :- dataRef(name, d) }
          in s |-> [(_, (_, T))].
  
  //Simple data expressions
  typeOfDataExp(s, Number(_)) = NatType().
  typeOfDataExp(s, True())    = BoolType().
  typeOfDataExp(s, False())   = BoolType().
  typeOfDataExp(s, EmptyList()) = ListType(AnyType()).
  typeOfDataExp(s, EmptyBag())  = BagType(AnyType()).
  typeOfDataExp(s, EmptySet())  = SetType(AnyType()).
  
  //Lists sets and bags
  typeOfDataExp(s, List(dexps))  = T :- {Us V}
    typeOfDataExps(s, dexps) == Us,
    T == ListType(V).
  typeOfDataExp(s, Set(dexps))  = T :- {Us V}
    typeOfDataExps(s, dexps) == Us,
    T == SetType(V).
  typeOfDataExp(s, Bag(bagElements))  = T :- {Ts}
    bagElementsOK(s, bagElements) == T.
  
  bagElementsOK maps bagElementOK(*, list(*)) = *
  bagElementOK : scope * BagEnumElt -> Type
  bagElementOK(s, BagElement(dexp1, dexp2)) = T :- {TV}
    typeOfDataExp(s, dexp1) == TV, 
    typeOfDataExp(s, dexp2) == NatType(), //TODO Subtype
    T == BagType(TV).

  //Mappings
  typeOfDataExp(s, FunctionUpdate(de1, de2, de3)) = TFun :- {T2 T3}
    typeOfDataExp(s, de1) == TFun,
    TFun == FunctionType([T2], T3),
    typeOfDataExp(s, de2) == T2,
    typeOfDataExp(s, de3) == T3.
  
  typeOfDataExp(s, FunctionApp(dfun, dargs)) = TFunApp :- {TFun TArgs}
    typeOfDataExp(s, dfun) == TFun,
    typeOfDataExps(s, dargs) == TArgs,
    TFun == FunctionType(TArgs, TFunApp). //TODO subtyping
    
  typeOfDataExp(s, Lambda(varsDecls, dexp)) = TLambda :- {s_lambda TLambdaRet}
    new s_lambda,
    s_lambda -P-> s,
    bindVarsDecls(s_lambda, varsDecls),
    typeOfDataExp(s_lambda, dexp) == TLambdaRet.

rules
  bindVarDecl : scope * string * Type
  bindVarsDecl : scope * VarsDecl
  bindVarsDecls maps bindVarsDecl(*, list(*))
  bindVarDeclNames maps bindVarDecl(*, list(*), *)
  
  bindVarsDecl(s, VarsDecl(names, sexp)) :- {T}
    typeOfSortExp(s, sexp) == T,
    bindVarDeclNames(s, names, T).
    
  bindVarDecl(s, name, T) :-
    s -> Var{name@name} with typeOfDecl T.

rules
  dataRef : string * occurrence
  
  dataRef(x, StructConstructor{x@_}).
  dataRef(x, Function{x@_}).
  dataRef(x, Var{x@_}).

//-----------------------------------------------------------------------------
//Built in functions
//head on list
//tail on list
//count(a,b): Bag(S) * S -> Nat
//Set2Bag: Set(S) -> Bag(S)
//Bag2Set: Bag(S) -> Set(S)

//-----------------------------------------------------------------------------
//Types
rules
  getType : Type -> Type
  allTypesTheSame maps getType(list(*)) = *
  
  getType(t) = t.
 